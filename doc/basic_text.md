# Տեքստերի ներկայացման մասին

Տեքստը չփոփոխվող (immutable) օբյեկտ է։ Վերագրման գործողության 
ժամանակ այն պատճենվում է, իս արդեն ոչ պետքական նմուշները 
ոչնչացվում են։ Տեքստային օբյեկտ վերադարձնող ֆունկցիաները միշտ
վերադարձնում են նոր ստեղծված օբյեկտ։

Օրինակ, `&` գործողության համար կարելի է գրել այսպիսի մի ֆունկցիա.

```c
char *text_concatenate(const char *so, const char *si)
{
  char *res = malloc(1 + strlen(so) + strlen(si));
  strcpy(res, so);
  strcat(res, si);
  return res;
}
```

Իսկ երբ BASIC-IR ծրագրում հանդիպում է `LET a$ = "Ok" & "?"` տեսքի
հրաման, ապա պետք է կազմակերպել մոտավորապես հետևյալ տիպի կոդ։

```c
const char *g_str_0 = "Ok";
const char *g_str_1 = "?";

/* ... */

char *temp_0 = text_concatenate(g_str_0, g_str_1);
free(a);
char *a = text_clone(temp_0);
free(temp_0);

/* ... */
```

__* * *__

Ենթածրագրի մարմնում տեքստային օբյեկտները կարող են «հայտնվել» երեք 
տեղից. ա) որպես տեքստային արժեք վերադարձնող ենթածրագրի անուն,
բ) որպես ենթածրագրի պարամետր և գ) որպես լոկալ փոփոխական։ Առաջին 
դեպքում պետք է malloc-ով ստեղծել լռելության արժեք, բայց ենթածրագրի
վերջում այդ փոփոխականի արժեքը պետք չէ ջնջել, որովհետև այն վերադարձվում
է կանչվող կետին, և կանչողն այդ արժեքը կհամարի ժամանակավոր արժեք ու
օգտագործելուց հետո կջնջի։ Երկրորդ դեպքում պարամետրով եկած արժեքը 
text_clone-ի միձոցով պատճենվում և կապվում է լոկալ հասցեին, իսկ 
ենթածրագրի ավարտին այդ հասցեին կապված հիշողությունն ազատվում է։
Այս դեպքում կանչի ժամանակ փոխանցված արժեքը չի փչանում։ Երրորդ 
դեպքում malloc-ով ստեղծվում է լռելության արժեք, իսկ վերջում ազատվում
է զբաղեցրած հիշողությունը։

Օրինակ.

```basic
SUB f$(x$, y)
  LET a$ = "Ok"
END SUB
```

```c
const char *g_str_0 = "Ok";

char *f(const char *x, double y)
{
    char *f_a = NULL;
    char *x_a = NULL;
    souble *y_a = NULL;
    char *a_a = NULL;

    f_a = malloc(1);
    x_a = text_copy(x);
    y_a = &y;
    a_a = malloc(1);

    free(a_a);
    a_a = text_clone(g_str_0);

    free(x_a);
    free(a_a);
}
```


