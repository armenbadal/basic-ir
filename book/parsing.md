
# BASIC-IR լեզվի վերլուծությունը

Այս գլխում ես պատմում եմ BASIC-IR լեզվով գրված ծրագրերի տեքստից _աբստրակտ քերականական ծառի_ ստացման պրոցեսը։ Եվ քանի որ առաջնային նպատակը ծառի կառուցումն է, սկսեմ հենց դրա նկարագրությունից։


## Աբստրակտ քերականական ծառ

BASIC-IR լեզվով գրված ծրագրի տեքստի վերլուծության արդյունքում կառուցվող _աբստրակտ քերականական ծառը_ կարող է պարունակել երկու տիպի հանգույցներ․ `Expression` և `Statement`։ Այս երկուսն էլ աբստրակտ դասեր են, որոնցից առաջինից ժառանգվում են _արտահայտությունները_ մոդելավորող դասերը, իսկ երկրորդից՝ _հրամանները_ մոդելավորող դասերը։


### Կոդի գեներացիայի ինտերֆեյսները

`Expression` և `Statement` դասերն իրականացնում են նպատակային կոդ գեներացնող երկու ինտերֆեյսներ՝ LLVM IR կոդի գեներացիայի `CodeIR` ինտերֆեյսը, և աբստրակտ քերականական ծառի՝ _Lisp_ ներկայացման `LispAst` ինտերֆեյսը։

`CodeIR` ինտերֆեյսի `code` միակ վիրտուալ ֆունկցիան պատասխանատվություն է կրում իր արգումենտում տրված `IRBuilder` օբյեկտի օգնությամբ LLVM IR հրամանների հաջորդականության ստեղծման համար։

````c++
class CodeIR {
public:
  virtual llvm::Value* code(llvm::IRBuilder<>&) = 0;
};
````

`LispAst` ինտերֆեյսի `lisp` միակ վիրտուալ ֆունկցիան իր արգումենտում տրված `ostream` օբյեկտի մեջ է գրում աբստրակտ քերականական ծառի ամեն մի հանգույցի՝ Լիսպ լեզվի ստրուկտուրայի նմուշի տեսքով ներկայացումը։

````c++
class LispAst {
public:
  virtual void lisp(std::ostream&) = 0;
};
````

Աբստրակտ քերականական ծառի՝ Լիսպ լեզվի տվյալների տեսքով ներկայացումն ինձ օգնում է երկու գործում։ Նախ՝ շարահյուսական վերլուծությունից հետո միանգամից տեսնում եմ կառուցված ծառը։ Երկրորդ՝ հետագայում պատրաստվում եմ դրանց հիման վրա կոդի գեներատոր գրել ոչ միայլ LLVM IR լեզվի համար, այլ նաև ուրիշ միջանկյալ լեզուների համար (օրինակ, C--)։


### Կոմպիլյացիայի միավորի մոդելը

Նախաբանում նշեցի, որ BASIC-IR լեզվով գրված ծրագիրը՝ _կոմպիլյացիայի միավորը_, ֆունկցիաների ու պրեցեդուրաների սահմանումների (նաև հայտարարությունների) հաջորդականություն է։ `Module` դասը ես նախատեսել եմ կոմպիլյացիայի միովորը (մոդուլը) ներկայացնելու համար։ Այս դասի `name` դաշտը մոդուլի անունն է, այն ոչ մի իմաստ չի կրում և ես դրա մեջ գրում եմ կոմպիլյացիայի տրված ֆայլի անունը։ Իսկ `subs` դաշտը մոդուլում հայտարարված կամ սահմանված ենթածրագրերի ցուցակն է։

````c++
class Module {
private:
  std::string name;
  std::vector<Function*> subs;
  /* ... */
public:
  Module(const std::string&);
  void addFunction(Function*);
  /* ... */
};
````


### Ենթածրագրերի մոդելը

BASIC-IR լեզվի _ֆունկցիաների_ ու _պրոցեդուրաների_ (_ենթածրագրերի_) մոդելները ներկայացնելու համար նախատեսել եմ `Function` դասը։ Սրա `name` դաշտը ցույց է տալիս ենթածրագրի անունը, `args` դաշտը արգումենտների ցուցակն է, որ աամեն մի տարրը անուն֊տիպ զույգ է, `type` դաշտը վերադարձվող արժեքի տիպն է, որը պրոցեդուրաների դեպքում ստանում է `VOID` պայմանական արժեքը և `body` դաշտը ենթածրագրի մարմինը կազմող հրամանների հաջորդականության ցուցիչն է։

````c++
class Function : public CodeIR, public LispAst {
public:
  std::string name;          // անուն
  vectornametype args;       // պարամետրեր
  std::string type;          // տիպ
  Statement* body = nullptr; // մարմին
  /* ... */
public:
  Function(const std::string&, const vectornametype&, const std::string&);
  /* ... */
};
````

Բացի `Expression` և `Statement` դասերից աբստրակտ երականական ծառի համար են նաև `Function` և `Module` դասերը։


### Արտահայտությունների մոդելը

Թվաբանական, համեմատման ու տրամաբանական արտահայտությունների համար բազային դաս է հանդիսանում `Expression` աբստրակտ դասը։ `env` ցուցիչը կապված է այն ենթածրագրի օբյեկտին, որի ներսում գտնվում է արտահայտությունը։ `type` դաշտը արտահայտության տիպը ցույց տվող ժառանգվող ատրիբուտ է։ `TyBoolean`, `TyInteger`, `TyDouble` և `TyVoid` տողային ստատիկ հաստատունները նախատեսված են BASIC-IR լեզվի ներդրված տիպերը նշանակելու համար։

````c++
class Expression : public CodeIR, public LispAst {
public:
  static const std::string TyBoolean;
  static const std::string TyInteger;
  static const std::string TyDouble;
  static const std::string TyVoid;
protected:
  Function* env{nullptr};
public:
  std::string type;
public:
  virtual ~Expression() {}
  virtual void setEnv(Function* e) { env = e; }
};
````


### Հրամանների մոդելը

````c++
class Statement : public CodeIR, public LispAst {
protected:
  Function* env;
public:
  virtual ~Statement() {}
  virtual void setEnv(Function* e) { env = e; }
};
````

## Նիշային վերլուծություն


