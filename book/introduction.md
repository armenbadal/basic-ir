
# Ներածություն

Այստեղ նկարագված է հանրահայտ Բեյսիկ (BASIC) լեզվի մի տարատեսակի կոմպիլյատորի իրականացումը։ Ես նպատակ եմ դրել մանրամասնորեն նկարագրել կոմպիլյատորների ստեղծման հիմնական քայլերը։ Թեև առավել ուշադրություն եմ դարձնում LLVM IR կոդի գեներացիային, բայց, անհրաժեշտությունից ելնելով, պատմում եմ նաև _նիշային_ վերլուծության, _շարահյուսական_ վերլուծության, _սիմվոլների աղյուսակի_, _տիպերի ստուգման_ և _աբստտրակտ քերականական ծառի_ մասին։


## BASIC-IR լեզուն

Ինչպես արդեն նշեցի, BASIC-IR լեզուն __Բեյսիկ__ լեզվի մի տարատեսակ է։ Այն հնարավորություն է տալիս աշխատել ներդրված _ամբողջաթիվ_, _իրական_ և _բուլյան_ տիպի սկալյար արժեքների հետ (հետագայում ավելացնելու եմ նաև զանգվածներն ու կառուցվածքները)։ Արժեքների (տվյալների) հետ կարելի է կատարել թվաբանական, տրամաբանական և համեմատման գործողություններ։ Օգտագործելուց առաջ բոլոր փոփոխականները պետք է հայտարարվեն և անպայման պետք է նշվի դրանց տիպը։ Տիպերը խստորեն ստուգվում են վերլուծության ժամանակ, իսկ անհամապատասխանությունների դեպքում կոմպիլյատորը հայտնում է սխալի մասին։ Փոփոխականին արժեք է տրվում _վերագրման_ հրամանով։ Ծրագրի ընթացքը ղեկավարվում է _ճյուղավորման_ (`If`) և _կրկնման_ (`For`, `While`) հրամաններով։

Օրինակ, `(0,N)` միջակայքի կենտ թվերն արտածող պրոցեդուրան կունենա հետևյալ տեսքը։

````basic
Sub Odds n As Double
  Dim i As Double
  For i = 1 To n
    If i \ 2 = 1 Then
      Print i
    End If
  End For
End Sub
````



## BASIC-IR լեզվի շարահյուսությունը

Ստորև ես EBNF (Extended Backus-Naur Form) գրառման օգտագործմամբ նկարագրում եմ BASIC-IR լեզվի շարահյուսությունը՝ մանրամասն բացատրություններով։

BASIC-IR լեզվով գրված տեքստը ֆունկցիաների և պրոցեդուրաների հայտարարությունների կամ սահմանումների հաջորդականություն է։

````
Program = { Declare | Function | Subroutine }.
````

`Declare` ծառայողական բառով սկսվում են ֆունկցիաների կամ պրոցեդուրաների _հայտարարությունները_։ Այս բառից հետո պետք է նշել հայտարարվող ֆունկցիայի կամ պրոցեդուրայի _վերնագիրը_։

````
Declare = 'Declare' (FuncHeader | SubrHeader).
````

_Ֆունկցիայի_ վերնագիրը սկսվում է `Function` ծառայողական բառով, որին հաջորդում է ֆունկցիայի _անունը_, ապա _պարամետրերի ցուցակը_՝ `(` և `)` փակագծերի մեջ, և վերջում՝ `As` ծառայողական բառից հետո, նշվում է ֆունկցիայի _վերադարձրած արժեքի տիպը_։

````
FuncHeader = 'Function' 'Ident' '(' [ NameDecl { ',' NameDecl } ] ')' 'As' 'Ident' Eols.
````

_Պրոցեդուրայի_ վերնագիրը սկսվում է `Sub` ծառայողական բառով, որին հաջորդում է պրոցեդուրայի _անունը_ և _պարամետրերի ցուցակը_ (առանց `(` և `)` փակագծերի)։

````
SubrHeader = 'Sub' 'Ident' [ NameDecl { ',' NameDecl } ] Eols.
````

Ֆունկցիայի և պրոցեդուրայի պարամետրը նկարագրելիս պետք է նշել դրա _անունն_ ու _տիպը_։

````
NameDecl = 'Ident' 'As' 'Ident'.
````

Ֆունկցիա սահմանելիս պետք է գրել ֆունկցիայի վերնագիրը, ապա թվարկել ֆունկցիայի _մարմնի_ հրամանները, և սահմանումն ավարտել `End` և `Function` ծառայողական բառերով։

````
Function = FuncHeader { Statement } 'End' 'Function' Eols.
````

Նույն կերպ սահմանվում է նաև պրոցեդուրան։

````
Soubroutine = SubrHeader { Statements } 'End' 'Sub' Eols.
````

Ամենապարզ ու ամենակարևոր հրամանը փոփոխականի _հայտարարման_ ու _սահմանման_ `Dim` հրամանն է։ Այս տվյալ ֆունկցիայում կամ պրոցեդուրայում ներմուծում է տրված անունով և տրված տիպն ունեցող փոփոխական, որի տեսանելիության տիրույթը տարածվում է մինչև ֆունկցիայի կամ պրոցեդուրայի վերջը։

````
Statement = 'Dim' 'Ident' 'As' 'Ident' Eols.
````

Փոփոխականին նոր արժեք է տրվում _վերագրման_ հրամանով։ Այն իրենից ներկայացնում է `=` նշանը, որի ձախ կողմում փոփոխականն է, իսկ աջում արտահայտություն է, որի արժեքը հաշվարկվում և վերագրվում է փոփոխականին։

````
Statement = 'Ident' '=' Disjunction Eols
````

_Պրոցեդուրայի կանչի_ հրմանը նույնպես սկսվում է իդենտիֆիկատորով․ դա պրոցեդուրայի անունն է։ Սրան հետևում է ստորակետով իրարից անջատված արտահայտությունների ցուցակ։ Այդ արտահայտությունների հաշվարկված արժեքները փոխանցվում են որպես պրոցեդուրայի պարամետրերի արժեքներ։

````
Statement = 'Ident' [Disjunction { ',' Disjunction }] Eols
````



